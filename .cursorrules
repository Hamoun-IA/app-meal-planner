# Meal App Planner - Cursor AI Rules

## Project Context
You are working on a PWA meal planning application with AI capabilities built with Next.js 14, TypeScript, Prisma, and PostgreSQL. The UI is already implemented - focus ONLY on backend, API routes, and business logic.

## Tech Stack
- Next.js 14 (App Router)
- TypeScript (strict mode)
- Prisma ORM with PostgreSQL + pgvector
- OpenAI API (GPT-4, embeddings)
- LangChain for AI orchestration
- Redis for caching
- Zod for validation

## Code Style & Standards

### TypeScript
- Use strict TypeScript with explicit types
- Prefer interfaces over types when possible
- Use proper error handling with try/catch
- Return proper typed responses

### Naming Conventions
- Files: kebab-case (recipe-service.ts)
- Functions/Variables: camelCase
- Classes/Interfaces: PascalCase
- Constants: UPPER_SNAKE_CASE
- Database: snake_case (as defined in schema.prisma)

### API Routes
- Use Next.js 14 App Router conventions
- Always validate input with Zod schemas
- Return consistent JSON responses: `{ data?: T, error?: string, status: number }`
- Handle errors gracefully with proper status codes
- Use streaming for AI chat endpoints

## Key Implementation Rules

### Database & Prisma
- Always use transactions for multi-table operations
- Generate embeddings (768 dimensions) for recipes on create/update
- Use pgvector for semantic search with HNSW indexes
- Normalize ingredient names (lowercase, singular)
- Use DEFAULT_USER_ID from env for all user-related operations

### AI Integration
- Use LangChain for agent orchestration
- Implement 3 specialized agents: Chef, Planner, Chat
- Always check MealHistory for recent meals (<7 days)
- Verify FamilyPreferences before suggestions
- Use streaming responses for chat endpoints
- Implement proper token management and rate limiting

### Validation Rules (CRITICAL)
1. **Recipes**: Must have name, 2+ instructions with verbs, 1+ ingredients
2. **Units**: Validate against ingredient's allowed units
3. **Duplicates**: Check >85% similarity before creating
4. **Coherence**: Verify dish type matches ingredients
5. **Dates**: No future dates except for planning

### Error Handling
- Use custom AppError class for operational errors
- Log all errors with context
- Return user-friendly error messages
- Never expose internal details in production

### Performance
- Cache frequently accessed data in Redis
- Use database indexes effectively
- Implement pagination (default: 10 items)
- Bundle API calls when possible
- Use React Query on frontend for caching

## File Structure Pattern
```typescript
// route.ts example
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { prisma } from '@/lib/db/prisma';
import { validateRequest } from '@/lib/utils/validation';

const schema = z.object({
  // Define schema
});

export async function POST(req: NextRequest) {
  try {
    const body = await validateRequest(req, schema);
    // Implementation
    return NextResponse.json({ data: result }, { status: 201 });
  } catch (error) {
    // Error handling
  }
}
```

## Service Pattern
```typescript
// service.ts example
export class RecipeService {
  async create(data: RecipeCreateInput): Promise<Recipe> {
    // 1. Validate coherence
    // 2. Check duplicates
    // 3. Generate embedding
    // 4. Create with transaction
    // 5. Return created recipe
  }
}
```

## Testing Requirements
- Unit tests for all services and utilities
- Integration tests for API routes
- Mock external services (OpenAI, Redis)
- Test error scenarios thoroughly
- Maintain >80% code coverage

## Security Considerations
- No authentication needed (single user app)
- Validate all inputs
- Sanitize data before storage
- Use environment variables for secrets
- Implement rate limiting on AI endpoints

## DO NOT
- Don't implement UI components (already done)
- Don't create user authentication
- Don't skip validation
- Don't ignore error handling
- Don't hardcode configuration values
- Don't create synchronous file operations

## ALWAYS
- Check existing types in schema.prisma
- Follow the error handling pattern
- Generate embeddings for searchable content
- Consider family preferences in suggestions
- Validate against business rules from gestion_erreurs_critiques_meal_appHAM.md

## Common Patterns

### Embedding Generation
```typescript
const embedding = await openai.embeddings.create({
  model: "text-embedding-3-small",
  input: text,
});
```

### Vector Search Query
```typescript
const results = await prisma.$queryRaw`
  SELECT * FROM recipes 
  ORDER BY embedding <=> ${embedding}::vector 
  LIMIT ${k}
`;
```

### Streaming Response
```typescript
const stream = new ReadableStream({
  async start(controller) {
    // Stream implementation
  }
});
return new Response(stream, {
  headers: { 'Content-Type': 'text/event-stream' }
});
```