generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// Enum for Difficulty levels
enum Difficulty {
  FACILE
  MOYEN
  DIFFICILE
}

// Enum for Type de plat (based on examples: Dessert, Plat principal, Accompagnement, etc.)
// You can extend this as needed
enum DishType {
  DESSERT
  PLAT_PRINCIPAL
  ACCOMPAGNEMENT
  ENTREE
  // Add more if required
}

// Enum for Unit of Measure (based on descriptions: g, kg, ml, etc.)
// This is a global enum; ingredients can reference multiple, but for simplicity, we'll use a string array in Ingredient model
enum UnitType {
  G
  KG
  ML
  CL
  L
  C_A_C  // c. à c.
  C_A_S  // c. à s.
  PINCEE
  POIGNEE
  BOUQUET
  GOUTTE
  PIECE
  // Add more as needed
}

// Enum for Preference Type
enum PreferenceType {
  LIKE
  DISLIKE
}

// Enum for Target Type in FamilyPreference
enum TargetType {
  INGREDIENT
  RECIPE
}

// Model for Recipes (with embedding for RAG)
model Recipe {
  id                String            @id @default(uuid()) @db.Uuid
  name              String            // Nom de la recette
  prepTime          Int?              // Temps de préparation (minutes)
  cookTime          Int?              // Temps de cuisson (minutes)
  difficulty        Difficulty?       // Difficulté
  dishType          DishType?         // Type de plat
  instructions      String[]          // Instructions: array of strings for structured steps
  tips              String?           // Conseils (optional)
  imageUrl          String?           // URL de l'image de la recette
  servings          Int?              // Nombre de portions (default: 4)
  embedding         String?           @db.Text // Embedding vector for RAG (stored as JSON string)
  ingredients       RecipeIngredient[] // Many-to-many relation to Ingredients via junction table
  mealHistories     MealHistory[]     // References in MealHistory

  @@map("recipes")
}

// Junction model for Recipe <-> Ingredient many-to-many
model RecipeIngredient {
  recipeId    String   @db.Uuid
  ingredientId String   @db.Uuid
  quantity     Float    // Quantité numérique (ex: 300)
  unit         UnitType // Unité de mesure (from enum)

  recipe      Recipe    @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  ingredient  Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  @@id([recipeId, ingredientId])
  @@map("recipe_ingredients")
}

// Model for Ingredients (optional embedding added for potential RAG on ingredients)
model Ingredient {
  id          String            @id @default(uuid()) @db.Uuid
  name        String            // Nom de l'ingrédient (standardized)
  categoryId  String?           @db.Uuid // Foreign key to Category
  category    Category?         @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  units       UnitType[]        // Array of applicable units (since multiple units per ingredient)
  embedding   String?           @db.Text // Optional: Embedding for semantic search on ingredients (stored as JSON string)
  recipes     RecipeIngredient[] // Many-to-many relation

  @@map("ingredients")
}

// Model for Categories (for shopping list and possibly ingredients)
model Category {
  id             String           @id @default(uuid()) @db.Uuid
  name           String           @unique // Contrainte unique pour éviter les doublons
  linkedItemId   String?          @db.Uuid // Optional liaison to Ingredient or ShoppingItem ID
  linkedItemType String?          // To specify if linked to 'ingredient' or 'shopping_item'
  ingredients    Ingredient[]     // Relation to Ingredients
  shoppingItems  ShoppingItem[]   // Relation to ShoppingItems

  @@map("categories")
}

// Model for Shopping List Items (Liste de gestion des courses)
model ShoppingItem {
  id          String    @id @default(uuid()) @db.Uuid
  name        String    // Nom de l'article
  categoryId  String?   @db.Uuid
  category    Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("shopping_items")
}

// Model for MealHistory
model MealHistory {
  id        String   @id @default(uuid()) @db.Uuid
  recipeId  String   @db.Uuid
  date      DateTime // Date du repas
  notes     String?  // Commentaires optionnels

  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@map("meal_history")
}

// Model for FamilyPreference
model FamilyPreference {
  id            String       @id @default(uuid()) @db.Uuid
  familyMember  String       // Nom ou rôle (ex: fils, maman)
  type          PreferenceType // like or dislike
  targetType    TargetType   // ingredient or recipe
  targetId      String       @db.Uuid // ID of the target (Ingredient or Recipe)
  notes         String?      // Additional info (ex: allergie)

  @@map("family_preferences")
}

// Additional notes:
// - The pgvector extension is enabled via 'extensions = [vector]' in datasource.
// - Embeddings are added to Recipe (primary for RAG on recipes) and optionally to Ingredient.
// - HNSW index for cosine similarity searches (as per architecture specs).
// - Dimension 768 based on "text-embedding-3-small (768 dimensions)" in docs (likely with dimension reduction).
// - To generate embeddings: In code, use OpenAI API to compute vectors on create/update, then save to DB.
// - For queries: Use Prisma raw queries or $queryRaw for vector searches, e.g., SELECT * FROM recipes ORDER BY embedding <=> [vector] LIMIT k;